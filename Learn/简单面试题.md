**1、面向对象的特征有哪些方面?**

答：面向对象的特征主要有以下几个方面：

- 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。
- 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。
- 封装：通常认为封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单）。
- 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。

**2、作用域public,private,protected,以及不写时的区别？**

答：区别如下：

作用域    当前类  同包 子类 其他

`public`        √        √       √      √

`protected`  √        √       √      ×

`default `      √       √       ×      ×

`private`       √        ×      ×      ×

不写时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。

**3、String 是最基本的数据类型吗?**

答：不是。

- Java中的基本数据类型只有8个：`byte、short、int、long、float、double、char、boolean`；除了基本类型（primitivetype）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。

**4、float f=3.4;是否正确?**

答:不正确。

- 3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f=(float)3.4;或者写成**floatf=3.4F**;。

**5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?**

- 对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。
- 而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。

**6、Java 有没有goto?**

goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实我个人并不认同这个说法，因为熟悉C语言的程序员都知道，在系统类库中使用过的那些单词才被称为保留字）

**7、int 和Integer 有什么区别?**

答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入不是对象的基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的封装类型（wrapper class），int的封装类就是Integer，从JDK1.5开始引入了自动封箱/解封箱机制，使得二者可以相互转换。

Java 为每个原始类型提供了封装类：

原始类型: `boolean，char，byte，short，int，long，float，double`

封装类型：`Boolean，Character，Byte，Short，Integer，Long，Float，Double`

**8、&和&&的区别？**

答：&运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &&!username.equals(“”)，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。

**9、解释内存中的栈（stack）、堆(heap)和静态存储区的用法。**

答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。

`String str = new String(“hello”);`

上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。

最新版本的JDK中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。

**10、Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?**

答：Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。

**11、swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?**

答：早期的JDK中，switch（expr）中，expr可以是byte、short、char、int。从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举，从1.7版开始，还可以是字符串（String）。长整型（long）是不可以的。

**12、用最有效率的方法计算2乘以8?**

答： 2 << 3（左移3位相当于乘以2的3次方）。

**13、数组有没有length()方法?String 有没有length()方法？**

答：数组没有length()方法，有length 的属性。String 有length()方法。

**14、在Java 中，如何跳出当前的多重嵌套循环？**

答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有些类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue）

